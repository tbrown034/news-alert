import { WatchpointId } from '@/types';
import { REGION_BASELINES } from './regionBaselines';

// =============================================================================
// ACTIVITY DETECTION
// =============================================================================
// Baselines come from a static file generated by:
//   npx tsx scripts/measure-region-baselines.ts
//
// The script fetches all sources, buckets posts into 6h windows, averages the
// complete buckets, and writes the results to src/lib/regionBaselines.ts.
// No DB dependency, no PPD math, no caching layers.
// =============================================================================

// Regions excluded from activity scoring due to insufficient source coverage.
// These always show NORMAL level regardless of post frequency.
const SCORING_EXCLUDED_REGIONS: WatchpointId[] = ['latam', 'asia', 'africa'];

// Minimum baseline per region â€” prevents zero baselines from causing false spikes
const MIN_REGION_BASELINE = 20;

// ---------- PUBLIC API ----------

export interface RegionActivity {
  level: 'critical' | 'elevated' | 'normal';
  count: number;
  baseline: number;
  multiplier: number;
  vsNormal: 'above' | 'below' | 'normal';
  percentChange: number;
}

/**
 * Calculate activity level for all regions.
 * Uses static measured baselines from regionBaselines.ts.
 * Items passed in should already be filtered to the 6h window by the API.
 */
export function calculateRegionActivity(
  items: { region: WatchpointId; timestamp: Date }[]
): Record<WatchpointId, RegionActivity> {
  const regions: WatchpointId[] = [
    'us', 'latam', 'middle-east', 'europe-russia', 'asia', 'africa',
  ];

  // Count ALL posts per region (items are already 6h filtered by API)
  const counts: Record<string, number> = {};
  let totalCount = 0;
  for (const item of items) {
    counts[item.region] = (counts[item.region] || 0) + 1;
    totalCount++;
  }

  const activity = {} as Record<WatchpointId, RegionActivity>;

  for (const region of regions) {
    const count = counts[region] || 0;
    const baseline = Math.max(1, REGION_BASELINES[region] || MIN_REGION_BASELINE);
    const multiplier = baseline > 0 ? Math.round((count / baseline) * 10) / 10 : 0;
    const percentChange = baseline > 0 ? Math.round(((count - baseline) / baseline) * 100) : 0;

    const MIN_ELEVATED_COUNT = 25;
    const MIN_CRITICAL_COUNT = 50;

    let level: RegionActivity['level'];
    if (SCORING_EXCLUDED_REGIONS.includes(region)) {
      level = 'normal';
    } else if (multiplier >= 5 && count >= MIN_CRITICAL_COUNT) {
      level = 'critical';
    } else if (multiplier >= 2.5 && count >= MIN_ELEVATED_COUNT) {
      level = 'elevated';
    } else {
      level = 'normal';
    }

    let vsNormal: 'above' | 'below' | 'normal';
    if (multiplier >= 1.5) vsNormal = 'above';
    else if (multiplier <= 0.5) vsNormal = 'below';
    else vsNormal = 'normal';

    activity[region] = { level, count, baseline, multiplier, vsNormal, percentChange };
  }

  // Compute "all" (aggregate across all regions)
  const allBaseline = Math.max(1, REGION_BASELINES['all'] || MIN_REGION_BASELINE);
  const allMultiplier = allBaseline > 0 ? Math.round((totalCount / allBaseline) * 10) / 10 : 0;
  const allPercentChange = allBaseline > 0 ? Math.round(((totalCount - allBaseline) / allBaseline) * 100) : 0;

  let allLevel: RegionActivity['level'] = 'normal';
  if (allMultiplier >= 5 && totalCount >= 50) allLevel = 'critical';
  else if (allMultiplier >= 2.5 && totalCount >= 25) allLevel = 'elevated';

  let allVsNormal: 'above' | 'below' | 'normal';
  if (allMultiplier >= 1.5) allVsNormal = 'above';
  else if (allMultiplier <= 0.5) allVsNormal = 'below';
  else allVsNormal = 'normal';

  activity['all' as WatchpointId] = {
    level: allLevel,
    count: totalCount,
    baseline: allBaseline,
    multiplier: allMultiplier,
    vsNormal: allVsNormal,
    percentChange: allPercentChange,
  };

  return activity;
}
